前文已经介绍了经典的[KMP算法](https://61mon.com/index.php/archives/183/)，本文继续介绍KMP算法的扩展，即扩展KMP算法。

**问题定义：**给定两个字符串S和T（长度分别为n和m），下标从0开始，定义`extend[i]`等于`S[i]...S[n-1]`与T的最长相同前缀的长度，求出所有的`extend[i]`。举个例子，看下表：

|     i     |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :-------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|     S     |  a   |  a   |  a   |  a   |  a   |  b   |  b   |  b   |
| extend[i] |  5   |  4   |  3   |  2   |  1   |  0   |  0   |  0   |
|     T     |  a   |  a   |  a   |  a   |  a   |  c   |      |      |

为什么说这是KMP算法的扩展呢？显然，如果在S的某个位置i有`extend[i]`等于m，则可知在S中找到了匹配串T，并且匹配的首位置是i。而且，扩展KMP算法可以找到S中所有T的匹配。接下来具体介绍下这个算法。


<!--more-->


## 一：算法流程
（1）

![](https://61mon.com/images/illustrations/ExtendedKMP/1.png)

如上图，假设当前遍历到S串位置i，即`extend[0]...extend[i - 1]`这i个位置的值已经计算得到。设置两个变量，a和p。p代表以a为起始位置的字符匹配成功的最右边界，也就是“p = 最后一个匹配成功位置 + 1”。相较于字符串T得出，**S[a...p)等于T[0...p-a)**。

再定义一个辅助数组`int next[]`，其中`next[i]`含义为：`T[i]...T[m - 1]`与T的最长相同前缀长度，m为串T的长度。举个例子：

|    i    |  0   |  1   |  2   |  3   |  4   |  5   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: |
|    T    |  a   |  a   |  a   |  a   |  a   |  c   |
| next[i] |  6   |  4   |  3   |  2   |  1   |  0   |

（2）

![](https://61mon.com/images/illustrations/ExtendedKMP/2.png)

椭圆的长度为`next[i - a]`，对比S和T，很容易发现，三个椭圆完全相同。如上图，此时`i + next[i - a] < p`，根据next数组的定义，此时`extend[i] = next[i - a]`。

（3）

![](https://61mon.com/images/illustrations/ExtendedKMP/3.png)

如果`i + next[i - a] == p`呢？如上图，三个椭圆都是完全相同的，`S[p] != T[p - a]`且`T[p - i] != T[p - a]`，但`S[p]`有可能等于`T[p - i]`，所以我们可以直接从`S[p]`与`T[p - i]`开始往后匹配，加快了速度。

（4）

![](https://61mon.com/images/illustrations/ExtendedKMP/4.png)

如果`i + next[i - a] > p`呢？那说明`S[i...p)`与`T[i-a...p-a)`相同，注意到`S[p] != T[p - a]`且`T[p - i]  == T[p - a]`，也就是说`S[p] != T[p - i]`，所以就没有继续往下判断的必要了，我们可以直接将`extend[i]`赋值为`p - i`。

（5）最后，就是求解next数组。我们再来看下`next[i]`与`extend[i]`的定义：

- **next[i]**： `T[i]...T[m - 1]`与T的最长相同前缀长度；
- **extend[i]**： `S[i]...S[n - 1]`与T的最长相同前缀长度。

恍然大悟，求解`next[i]`的过程不就是T自己和自己的一个匹配过程嘛，下面直接看代码。

## 二：代码
```c++
/**
 *
 * author 刘毅（Limer）
 * date   2017-03-12
 * mode   C++
 */
#include<iostream>
#include<string>
using namespace std;

/* 求解 T 中 next[]，注释参考 GetExtend() */
void GetNext(string & T, int & m, int next[])
{
    int a = 0, p = 0;
    next[0] = m;

    for (int i = 1; i < m; i++)
    {
        if (i >= p || i + next[i - a] >= p)
        {
            if (i >= p)
                p = i;

            while (p < m && T[p] == T[p - i])
                p++;

            next[i] = p - i;
            a = i;
        }
        else
            next[i] = next[i - a];
    }
}

/* 求解 extend[] */
void GetExtend(string & S, int & n, string & T, int & m, int extend[], int next[])
{
    int a = 0, p = 0;
    GetNext(T, m, next);

    for (int i = 0; i < n; i++)
    {
        if (i >= p || i + next[i - a] >= p) // i >= p 的作用：举个典型例子，S 和 T 无一字符相同
        {
            if (i >= p)
                p = i;

            while (p < n && p - i < m && S[p] == T[p - i])
                p++;

            extend[i] = p - i;
            a = i;
        }
        else
            extend[i] = next[i - a];
    }
}

int main()
{
    int next[100];
    int extend[100];
    string S, T;
    int n, m;
    
    while (cin >> S >> T)
    {
        n = S.size();
        m = T.size();
        GetExtend(S, n, T, m, extend, next);

        // 打印 next 和 extend
        cout << "next:   ";
        for (int i = 0; i < m; i++)
            cout << next[i] << " ";

        cout << "\nextend: ";
        for (int i = 0; i < n; i++)
            cout << extend[i] << " ";

        cout << endl << endl;
    }
    return 0;
}
```

数据测试如下：

![](https://61mon.com/images/illustrations/ExtendedKMP/5.png)

## 三：时间复杂度

对比KMP算法，很容易发现时间复杂度为$Θ(n+m)$。

## 四：参考文献

- CSDN. ACdreamer文. [扩展KMP算法](http://blog.csdn.net/acdreamers/article/details/8313828)
