前文已经介绍了经典的[KMP算法](http://www.61mon.com/index.php/archives/183/)，本文继续介绍KMP算法的扩展，即扩展KMP算法。

**问题定义：**给定两个字符串S和T（长度分别为n和m），下标从0开始，定义`extend[i]`等于`S[i]...S[n-1]`与T的最长相同前缀的长度，求出所有的`extend[i]`。举个例子，看下表：
|     i     |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |      |
| :-------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- |
|     S     |  a   |  a   |  a   |  a   |  a   |  b   |  b   |  b   |      |
| extend[i] |  5   |  4   |  3   |  2   |  1   |  0   |  0   |  0   |      |
|     T     |  a   |  a   |  a   |  a   |  a   |  c   |      |      |      |
为什么说这是KMP算法的扩展呢？显然，如果在S的某个位置i有`extend[i]`等于m，则可知在S中找到了匹配串T，并且匹配的首位置是i。而且，扩展KMP算法可以找到S中所有T的匹配。接下来具体介绍下这个算法。


<!--more-->


## 一：算法流程
（1）
![](http://oi0fekpsr.bkt.clouddn.com/%E6%89%A9%E5%B1%95KMP_1.png#mirages-width=760&mirages-height=310&mirages-cdn-type=1)

如上图，假设当前遍历到S串位置i，即`extend[0]...extend[i - 1]`这i个位置的值已经计算得到。设置两个变量，a和p。p代表以a为起始位置的字符匹配成功的最右边界，也就是“p = 最后一个匹配成功位置 + 1”。相较于字符串T得出，**S[a...p)等于T[0...p-a)**。

再定义一个辅助数组`int next[]`，其中`next[i]`含义为：`T[i]...T[m - 1]`与T的最长相同前缀长度，m为串T的长度。注意：这里的前缀可以包含自身，这和前面文章[KMP算法](http://www.61mon.com/index.php/archives/183/)中的前缀有所不同，举个例子：

|    i    |  0   |  1   |  2   |  3   |  4   |  5   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: |
|    T    |  a   |  a   |  a   |  a   |  a   |  c   |
| next[i] |  6   |  4   |  3   |  2   |  1   |  0   |

（2）
![](http://oi0fekpsr.bkt.clouddn.com/%E6%89%A9%E5%B1%95KMP_2.png#mirages-width=760&mirages-height=310&mirages-cdn-type=1)

椭圆的长度为`next[i - a]`，对比S和T，很容易发现，三个椭圆完全相同。如上图，此时`i + next[i - a] < p`，根据next数组的定义，此时`extend[i] = next[i - a]`。

（3）
![](http://oi0fekpsr.bkt.clouddn.com/%E6%89%A9%E5%B1%95KMP_4.png#mirages-width=760&mirages-height=310&mirages-cdn-type=1)

如果`i + next[i - a] == p`呢？如上图，三个椭圆都是完全相同的，此时我们可以直接从`S[p]`与`T[p - i]`开始往后匹配，加快了速度。

（4）

![](http://oi0fekpsr.bkt.clouddn.com/%E6%89%A9%E5%B1%95KMP_3.png#mirages-width=760&mirages-height=310&mirages-cdn-type=1)

如果`i + next[i - a] > p`呢？仔细观察上图，若真是如此，则**p必等于n**！因为若p不等于n，则说明p（包括p）后面还有字符，那么我们记录的以a为起始位置的字符匹配成功的最右边界就不是p了，而是到了红线位置。

既然p已等于n，那么显然`extend[i] = p - i` 。

（5）最后，就是求解next数组。我们再来看下`next[i]`与`extend[i]`的定义：
**next[i]**： `T[i]...T[m - 1]`与T的最长相同前缀长度；
**extend[i]**： `S[i]...S[n - 1]`与T的最长相同前缀长度。

恍然大悟，求解`next[i]`的过程不就是T自己和自己的一个匹配过程嘛，下面直接看代码。

## 二：代码
```c++
/**
 *
 * author 刘毅（Limer）
 * date   2017-03-12
 * mode   C++
 */
#include<iostream>
#include<string>
using namespace std;

/* 求解 T 中 next[]，注释参考 GetExtend() */
void GetNext(string & T, int & m, int next[])
{
    int a = 0, p = 0;
    next[0] = m;

    for (int i = 1; i < m; i++)
    {
        if (i >= p || i + next[i - a] >= p)
        {
            if (i >= p)
                p = i;

            while (p < m&&T[p] == T[p - i])
                p++;

            next[i] = p - i;
            a = i;
        }
        else
            next[i] = next[i - a];
    }
}

/* 求解 extend[] */
void GetExtend(string & S, int & n, string & T, int & m, int extend[], int next[])
{
    int a = 0, p = 0;
    GetNext(T, m, next);

    for (int i = 0; i < n; i++)
    {
        if (i >= p || i + next[i - a] >= p) // i >= p 的作用：举个典型例子，S 和 T 无一字符相同
        {
            if (i >= p)
                p = i;

            while (p < n && p - i < m && S[p] == T[p - i])
                p++;

            extend[i] = p - i;
            a = i;
        }
        else
            extend[i] = next[i - a];
    }
}

int main()
{
    int next[100];
    int extend[100];
    string S, T;
    int n, m;
    
    while (cin >> S >> T)
    {
        n = S.size();
        m = T.size();
        GetExtend(S, n, T, m, extend, next);

        // 打印 next 和 extend
        cout << "next:   ";
        for (int i = 0; i < m; i++)
            cout << next[i] << " ";

        cout << "\nextend: ";
        for (int i = 0; i < n; i++)
            cout << extend[i] << " ";

        cout << endl << endl;
    }
    return 0;
}
```

数据测试如下：

![](http://oi0fekpsr.bkt.clouddn.com/%E6%89%A9%E5%B1%95KMP_5.png#mirages-width=386&mirages-height=327&mirages-cdn-type=1)

## 三：时间复杂度

对比KMP算法，很容易发现时间复杂度为$Θ(n+m)$。

**参考文献：**
[ 1 ] NOALGO. [扩展KMP算法](http://noalgo.info/340.html)
[ 2 ] ACdreamer. [扩展KMP算法](http://blog.csdn.net/acdreamers/article/details/8313828)
