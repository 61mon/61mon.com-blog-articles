我们首次接触BFS和DFS时，应该是在数据结构课上讲的“图的遍历”。而本篇文章就来讲讲它们在搜索方面的应用和区别。（如果你是OI Beginner或者ACM Beginner，那么这篇文章正适合你）

**广度优先搜索算法（Breadth-First-Search，缩写为BFS）**，是一种利用**队列**实现的搜索算法。简单来说，其搜索过程和“湖面丢进一块石头激起层层涟漪”类似。

**深度优先搜索算法（Depth-First-Search，缩写为DFS）**，是一种利用**递归**实现的搜索算法。简单来说，其搜索过程和“不撞南墙不回头”类似。

举个例子，如下图，灰色代表墙壁，绿色代表起点，红色代表终点，规定每次只能走一步，且只能往下或右走。求一条绿色到红色的最短路径。

![](http://oi0fekpsr.bkt.clouddn.com/BFS%E5%92%8CDFS_1.png)

对于上面的问题，BFS和DFS都可以求出结果，它们的区别就是在复杂度上存在差异。我可以先告诉你，该题BFS是较佳算法。

### BFS

![](http://oi0fekpsr.bkt.clouddn.com/BFS%E5%92%8CDFS_2.gif)

如上图所示，从起点出发，对于每次出队列的点，都要遍历其四周的点。所以说BFS的搜索过程和“湖面丢进一块石头激起层层涟漪”很相似。

### DFS

![](http://oi0fekpsr.bkt.clouddn.com/BFS%E5%92%8CDFS_3.gif)

如上图所示，从起点出发，先把一个方向的点都遍历完才会改变方向，接着再把改变后方向上的点都遍历完.......所以说，DFS的搜索过程和“不撞南墙不回头”很相似。

### 总结

BFS常用于找单一的最短路线，它的特点是"搜到就是最优解"，而DFS用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）。

BFS和DFS是很重要的算法，仅凭一文就将其解释清楚，是不可能的，读者如果想要更深入地了解它们，建议去OJ上找一些相关赛题训练下，一定会给你一个别样的天地。